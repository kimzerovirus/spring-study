## DB락 

> 세션1이 트랜잭션을 시작하고 작업을 수행하는 동안(커밋을 하기 전) 세션2가 동시에 작업을 수행하여 데이터를 변경해버린다면 트랜잭션의 원자성이 깨지게 된다.<br/>
>
> 이런 문제를 해결하기 위해, 세션이 트랜잭션을 시작하고 작업을 수행하는 동안 커밋이나 롤백이 일어나기 전까지 다른 세션이 해당 데이터에 접근하지 못하게 막아야 한다.

## 스프링의 트랜잭션 매니저
1. 트랜잭션 매니저는 데이터소스를 통해 커넥션을 만들고 트랜잭션을 시작한다.
2. 트랜잭션 매니저는 트랜잭션이 시작된 커넥션을 트랜잭션 동기화 매니저에 보관.
3. 로직 수행시 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서 사용.
4. 트랜잭션이  종료되면 트랜잭션 매니저는 트랜잭션 동기화 매니저에 보관된 커넥션을 통해 트랜잭션을 종료하고, 커넥션도 종료.

**트랜잭션 동기화 매니저**
> 쓰레드 로컬을 사용하는데, 이 쓰레드 로컬을 사용하면 각각의 쓰레드마다 별도의 저장소가 부여되어 해당 쓰레드만 해당 데이터에 접근 가능한 격리된 환경을 제공한다. 즉, 멀티쓰레드 환경에서 안전하게 커넥션을 보관할 수 있다는 의미

## 스프링의 트랜잭션 AOP
> `@Transactional` 을 사용하면 스프링이 AOP를 사용해서 트랜잭션을 편리하게 처리해준다. <br/>
> 프록시를 사용하여 트랜잭션을 처리하는 객체와 비즈니스 로직을 처리하는 서비스 객체를 명확하게 분리해줌

## 예외

- 체크 예외 : 컴파일 시점에 알 수 있는 예외 메소드 옆에 적어주므로 밖으로 예외를 넘길 수 있음
  - 예외를 잡아서 반드시 처리해야 하는 문제일 경우 사용
  - 스프링의 Transcational 어노테이션은 기본 정책이 Unchecked Exception이므로 체크 예외 발생시 롤백이 안됨
  - 체크 예외 예시)
    - 계좌 이체 실패 예외
    - 결제시 포인트 부족 예외
    - 복구 불가능한 예외
- 언체크(런타임) 예외
  - 런타임 예외도 메소드명 옆에 명시하여도 되긴함