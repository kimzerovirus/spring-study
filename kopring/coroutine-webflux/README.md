코루틴과 기존 자바 진영의 멀티 프로그래밍의 차이
> 기존 자바의 멀티스레드 프로그래밍 방식은 사용자가 스레드를 기반으로 작업을 수행하도록 하였기 때문에 블로킹 문제와 콜백과 같은 복잡한 코드로 인해 비동기 처리에 한계가 있었다.
> 코루틴은 **경량 스레드**를 통해 간결한 방식으로 블로킹 없이 비동기 작업을 수행할 수 있게 하며, 비동기 작업을 구조화해서 코루틴이 동작하는 범위를 한정해 비동기 작업을 관리할 수 있게 하여 안정성을 높였다.

##### JVM 스레드
**사용자 스레드**

일반적으로 생성되는 스레드이다. 모든 사용자 스레드가 종료되면 JVM이 종료된다. 용도는 어플리케이션의 주요 작업을 수행한다. `main()`메서드에서 실행되는 스레드이다. 우선도가 높다.

**데몬 스레드**

백그라운드에서 사용자 스레드를 지원하는 스레드이다. 사용자 스레드가 모두 종료되면, 남아있는 데몬 스레드는 강제 종료된다. 용도는 로그 기록, 가비지 컬렉션, 모니터링 등 보조 작업이다. 우선도가 낮다.

##### 코루틴의 경량 스레드

코루틴은 스레드 블로킹 문제를 해결하기 위해 작업 단위 코루틴(작업 중 일시 중단할 수 있는 단위)을 일시 중단되면 더 이상 스레드 사용이 필요하지 않게 되므로 스레드의 사용 권한을 양보하여, 스레드를 다른 작업을 실행하는데 사용한다. 이후 일시 중단된 코루틴의 작업이 재개되는 시점에 다시 스레드가 할당되어 실행되게 하여 블로킹 문제를 해결했다.

- OS 스레드가 아닌 사용자 JVM 내부(사용자 스레드)에서 실행되고 스케줄링된다.
  - 코루틴은 프로그래머가 코루틴을 만ㄷ르어 코루틴 스캐줄러에 넘겨주면 스캐줄러가 알아서 스레드나 스레드풀에 해당 코루틴을 분배해 작업을 수행하는 방식이다.
- 일반 스레드는 전환시 OS에서 컨텍스트 스위칭하지만 코루틴은 함수 호출 수준의 전환만하므로 비용이 적다.
- 블로킹이 아니라 일시중단

이와 같은 이유로 *경량* 이라고 할 수 있다.
